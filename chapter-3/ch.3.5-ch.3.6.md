## 3. 코딩과 디버깅에 관하여

### 3.5 변수 범위의 이해
#### 산술 오버플로

 - 수학적/논리적으로는 완전히 정당한 알고리즘도 프로그램으로 구현했을 때는 예상과 다르게 동작하는 경우를 흔하게 볼 수 있는데 이러한 문제를 흔한 원인이 바로 산술 오버플로(arithmetic overflow)이다.
 - 현대에는 많은 라이브러리들에서 제공하는 표준 클래스로 인해 산술 오버플로를 신경 쓸 일이 크게 줄어들었지만 이런 클래스들은 훨씬 많은 메모리와 시간을 필요로 하기 때문에 여전히 이런 기법들을 공부할 가치는 충분하다.
 - 큰 정수를 다룰 때는 항상 변수의 형태에 주의하는 습관을 들이도록 한다.
 - 프로그램의 출력 값의 범위는 작지만 중간 과정에서 큰 값을 일시적으로 계산해야하는 경우 산술 오버플로가 일어난다.
 
 ```java
 int gcd(int a, int b); // 두 수의 최대공약수를 반환
 
 int lcm(int a, int b) {
  return (a * b) / gcd(a, b);
 }
 ```
 
 - 위 코드는 언뜻 보기에는 문제가 없지만 lcm(5000, 100000) 을 계산하는 경우 암산으로 이 두 수의 최소공배수는 100000임을 알 수있지만 중간 과정에서 50000과 100000만의 곱이 32비트 정수형 범위를 초과하기 때문에 산술 오버플로가 발생함.

#### 오버플로 피해가기

 - 오버플로를 피해가는 가장 간단한 방법은 충분히 더 큰 자료형을 사용하는 것.
 - 연산의 순서를 바꾸는것도 하나의 방법. 
 
 ```java
 int lcm(int a, int b) {
  return a * (b / gcd(a, b));
 }
 ```
 
 - gcd(a, b)는 a와 b 모두의 약수이니만큼, a와 b를 곱하기 전에 미리 gcd(a,b)로 나누어 버려도 나누어 떨어진다. 

#### 자료형의 프로모션
 - 피연산자의 자료형이 다르거나 자료형의 범위가 너무 작은 경우 컴파일러는 대게 이들을 같은 자료형으로 변환해서 계산하는데, 이를 프로모션이라 한다.
 - 프로모션은 대부분의 경우 신경쓸일이 없지만 가끔 알기 어려운 버그를 만드는 주역이 되기도 한다. 
 - 부호없는 정수를 사용할 경우 버그가 나타날 수 있음.
 - 부호없는 정수를 언어 차원에서 아예 지원하지 않는 자바에서는 관련 문제를 신경쓸 필요가 전혀 없다.
 
### 3.6 실수 자료형의 이해

 - 컴퓨터의 모든 실수 변수는 정확도가 제한된 근사 값을 저장
 - 가장 많은 컴퓨터/컴파일러들에서 사용되는 실수 표기 방식은 IEEE 754 표준이고 이 표준의 큰 특징은 아래와 같다.
 
 ```
 1. 이진수로 실수를 표기 
 2. 부동 소수점 표기법
 3. 무한대, 비정규 수 등의 특수한 값이 존재
 ```

 - 이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 근사값으로 저장되는데, 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져올 수 있다.
 - 실수 연산에서 계산의 오류를 해결하기 위해 몇가지 방안은 아래와 같음.
 
 ```
 1. 비교할 실수의 크기들에 비례한 오차 한도를 정한다.
 2. 상대 오차를 이용한다.
 ```
 
 - 정확한 실수의 연산이 아예 불가능한것은 아니고 정확하게 표현할 수 있는 값은 항상 정확하게 저장하도록 구현되어 있다. 정확하게 저장할 수 있는 수들의 대표적인 예는 가수부안의 들어가는 정수. 
 - 추가적인 자료 구조를 도입해서 정확한 사칙연산을 구현할 수 있음. 대표적인것이 자바의 BigDecimal
 - 실수 연산은 이처럼 제대로 행해지기 어렵기 때문에 실수 연산을 제대로 하는 가장 좋은 방법은 실수 연산을 아예 하지 않는 것.
 - 대부분의 경우 적절한 변형을 통해 실수 연산을 없앨 수 있다.
 
 ```
 1. 곱셈과 나눗셈의 순서를 바꾸기
 2. 양변 제곱하기 
 3. 실수 좌표를 써야 하는 기하 문제에서 좌표계를 가로 세로로 정수배 늘리면 정수만을 이용해 문제 푸는게 가능
 ```
